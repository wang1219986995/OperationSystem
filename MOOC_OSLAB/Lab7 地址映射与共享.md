# 地址映射与共享

本次实验的基本内容是：

- 用 Bochs 调试工具跟踪 Linux 0.11 的地址翻译（地址映射）过程，了解 IA-32 和 Linux 0.11 的内存管理机制；
- 在 Ubuntu 上编写多进程的生产者—消费者程序，用共享内存做缓冲区；
- 在信号量实验的基础上，为 Linux 0.11 增加共享内存功能，并将生产者—消费者程序移植到 Linux 0.11。








## 1 跟踪地址翻译过程

首先编写test.c 的代码如下：

```c
//test.c 代码
```



### 1.1 通过段表获取线性地址

编译好 Linux 0.11 后，首先通过运行 `./dbg-asm` 启动调试器，此时 Bochs 的窗口处于黑屏状态，再命令行中输入命令c，Linux 0.11 就正常启动了。启动在Bosch种执行test程序。

当 test 运行的时候，在命令行窗口按 `Ctrl+c`，Bochs 会暂停运行，进入调试状态。绝大多数情况下都会停在 test 内，显示类似如下信息：



```
(0) [0x00fcc082] 000f:00000082 (unk. ctxt): jz .+0x00000004 (0x10000088) ; 7404
<bochs:2> n
Next at t=488540355  // 如果指令不是cmp就使用单步执行命令n运行
(0) [0x00fcc084] 000f:00000084 (unk. ctxt): jmp .+0xfffffff5 (0x1000007b) ; ebf5
<bochs:3> n
Next at t=488540356
(0) [0x00fcc07b] 000f:0000007b (unk. ctxt): cmp dword ptr ds:0x4004, 0x00000000 ; 833d0440000000
<bochs:4>           // 直到定在cmp指令处

```

此时，cmp指令中的 `ds:0x4004` 就是变量 i 的地址。

现在，要通过段表找到 ds 所代表段基址。

每个在 IA-32 上运行的应用程序都有一个段表，叫 LDT，段的信息叫段描述符。

LDT 在哪里呢？ldtr 寄存器是线索的起点，通过它可以在 GDT（全局描述符表）中找到 LDT 的物理地址。

用 `sreg` 命令（是在调试窗口输入）：

```
<bochs:10> sreg
cs:s=0x000f, dl=0x00000003, dh=0x10c0fa00, valid=1
ds:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=3
ss:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
es:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
fs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
gs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
ldtr:s=0x0068, dl=0xa2d00068, dh=0x000082f9, valid=1
tr:s=0x0060, dl=0xa2e80068, dh=0x00008bf9, valid=1
gdtr:base=0x00005cb8, limit=0x7ff
idtr:base=0x000054b8, limit=0x7ff

```

（关于GDT、LDT及相关寄存器的介绍 http://t.zoukankan.com/yzl050819-p-4823057.html）

此处，ldtr=0x0068，二进制为 0000 0000 0110 1000 ，该寄存器的高13位为在LDT表的基址在GDT中的索引号（即 0000 0000 0110 1(二进制) = 13(十进制)）。而GDT的地址有gdtr给出，为 `gdtr:base=0x00005cb8, limit=0x7ff` 。用xp /32w 0x00005cb8 查看该地址开始的32字节的内容（即GDT表的前16项）如下所示：



```
<bochs:11> xp /32w 0x00005cb8 
[bochs]:
0x00005cb8 <bogus+       0>:	0x00000000	0x00000000	0x00000fff	0x00c09a00
0x00005cc8 <bogus+      16>:	0x00000fff	0x00c09300	0x00000000	0x00000000
0x00005cd8 <bogus+      32>:	0xb8880068	0x00008901	0xb8700068	0x00008201
0x00005ce8 <bogus+      48>:	0xf2e80068	0x000089ff	0xf2d00068	0x000082ff
0x00005cf8 <bogus+      64>:	0xd2e80068	0x000089ff	0xd2d00068	0x000082ff
0x00005d08 <bogus+      80>:	0x12e80068	0x000089fc	0x12d00068	0x000082fc
0x00005d18 <bogus+      96>:	0xa2e80068	0x00008bf9	0xa2d00068	0x000082f9
0x00005d28 <bogus+     112>:	0x00000000	0x00000000	0x00000000	0x00000000
<bochs:12> 

```

这里，我们需要的是GDT表中的索引号为13(即第14个)的项，使用 xp /2w `0x00005cb8+13*8 ` 查看该表项的内容，可以通过sreg命令查看ldtr行中 dl 和 dh 的值比较来确认该表项

```
<bochs:12> xp /2w 0x00005cb8+13*8 
[bochs]:
0x00005d20 <bogus+       0>:	0xa2d00068	0x000082f9
<bochs:13> sreg
cs:s=0x000f, dl=0x00000003, dh=0x10c0fa00, valid=1
ds:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=3
ss:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
es:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
fs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
gs:s=0x0017, dl=0x00003fff, dh=0x10c0f300, valid=1
ldtr:s=0x0068, dl=0xa2d00068, dh=0x000082f9, valid=1
tr:s=0x0060, dl=0xa2e80068, dh=0x00008bf9, valid=1
gdtr:base=0x00005cb8, limit=0x7ff
idtr:base=0x000054b8, limit=0x7ff
<bochs:14> 

```

由上可知，所需的段描述符值为 0x**a2d0**0068	0x**00**0082**f9**，根据段描述符的结构将加粗部分组合出LDT的物理地址为 0x00f9a2d0 （TODO: 这个地址到底是怎么组合的？）。

xp /8w 0x00f9a2d0  即可得到LDT的前4项内容：

```
<bochs:15> xp /8w 0x00f9a2d0 
[bochs]:
0x00f9a2d0 <bogus+       0>:	0x00000000	0x00000000	0x00000003	0x10c0fa00
0x00f9a2e0 <bogus+      16>:	0x00003fff	0x10c0f300	0x00000000	0x00f9b000
```



段寄存器 ds (也称段选择子) 的值为 0x0017，低三位为标识符，剩余位为LDT索引，索引值为2，所以取LDT表中的第三项，即 0x**0000**3fff	0x**10**c0f3**00** ， 对照寄存器信息ds一行中的 dl，dh可判断该值是否正确。组合出ds 的地址值为 0x1000 0000 。此时，可计算出 ds:0x4004 的值为 0x1000 4004 。通过calc ds:0x4004 命令可确认结果是否正确。

```
<bochs:16> calc ds:0x4004
0x10004004 268451844
<bochs:17> 
```

此时，可得到test程序中变量 i 的虚拟地址为 0x10004004 。



### 1.2 线性地址转换为物理地址

Linux 0.11 中通过两级页表寻址物理地址，线性地址的高10位为页目录号，中间10位为页框号，低12位为页内偏移。

由上述流程计算出的变量 i 的线性地址为 0x10004004 ，可得页目录号为64，页框号为4，页内偏移为4。

然后就可以通过页目录和页表去查该地址了。

页目录的位置由CR3寄存器指引，用 cerg 命令可以看到

```
<bochs:18> creg
CR0=0x8000001b: PG cd nw ac wp ne ET TS em MP PE
CR2=page fault laddr=0x10003000
CR3=0x00000000
    PCD=page-level cache disable=0
    PWT=page-level writes transparent=0
CR4=0x00000000: osxmmexcpt osfxsr pce pge mce pae pse de tsd pvi vme
<bochs:19> 
```

由上可以看到页目录的基址为 0x00000000。查看该地址处的内容，xp /68w 0 为：



```
<bochs:19> xp /68w 0
[bochs]:
0x00000000 <bogus+       0>:	0x00001027	0x00002007	0x00003007	0x00004027
0x00000010 <bogus+      16>:	0x00000000	0x00026294	0x00000000	0x00000000
0x00000020 <bogus+      32>:	0x00000000	0x00000000	0x00000000	0x00000000
0x00000030 <bogus+      48>:	0x00000000	0x00000000	0x00000000	0x00000000
0x00000040 <bogus+      64>:	0x00ffe027	0x00000000	0x00000000	0x00000000
0x00000050 <bogus+      80>:	0x00000000	0x00000000	0x00000000	0x00000000
0x00000060 <bogus+      96>:	0x00000000	0x00000000	0x00000000	0x00000000
0x00000070 <bogus+     112>:	0x00000000	0x00000000	0x00000000	0x00000000
0x00000080 <bogus+     128>:	0x00ff7027	0x00000000	0x00000000	0x00000000
0x00000090 <bogus+     144>:	0x00000000	0x00000000	0x00000000	0x00000000
0x000000a0 <bogus+     160>:	0x00000000	0x00000000	0x00000000	0x00000000
0x000000b0 <bogus+     176>:	0x00000000	0x00000000	0x00000000	0x00ffb027
0x000000c0 <bogus+     192>:	0x00fbe027	0x00000000	0x00000000	0x00000000
0x000000d0 <bogus+     208>:	0x00000000	0x00000000	0x00000000	0x00000000
0x000000e0 <bogus+     224>:	0x00000000	0x00000000	0x00000000	0x00000000
0x000000f0 <bogus+     240>:	0x00000000	0x00000000	0x00000000	0x00fc0027
0x00000100 <bogus+     256>:	0x00fa9027	0x00000000	0x00000000	0x00000000
<bochs:20> xp /w 0+64*4     // 此处是找到第65的表目录项
[bochs]:
0x00000100 <bogus+       0>:	0x00fa9027    
<bochs:21> 

```

页目录项的前20位为页表的地址，0x00fa9000。从该位置查看第5表项：

```
<bochs:22> xp /w 0x00fa9000+4*4            
[bochs]:
0x00fa9010 <bogus+       0>:	0x00fa7067
<bochs:23> 

```

由页表项的值 0x00fa7067，结合线性地址 0x10004004 ，可得物理地址为 0x00fa7004 。

```
<bochs:25> page 0x10004004
linear page 0x10004000 maps to physical page 0x00fa7000
<bochs:26> 

```

上述命令验证页的映射， `xp /w 0x00fa7004` 命令查看该处地址的值：

```
<bochs:26> xp /w 0x00fa7004
[bochs]:
0x00fa7004 <bogus+       0>:	0x12345678
<bochs:27> 

```

该处的值与变量i的值相同，由此可见，物理地址寻找正确。

通过命令 `setpmem 0x00fa7004 4 0` ，将  0x00fa7004 地址开始的 4 个字节都设为 0，再用 c 命令继续Bosch运行，可以看到test退出了。