# X86 汇编语言 



## 1 寄存器

不同的CPU,寄存器的个数、结构是不相同的。8086CPU有14个寄存器，每个寄存器有一个名称。

这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。所有的寄存器都是16位的。

### 1.1 通用寄存器

通用寄存器有4个： AX、BX、CX、DX。

这4个寄存器均可分为两个8位的寄存器来使用，例如，AX可分为 AH和AL。![Dingtalk_20220523133758](/Dingtalk_20220523133758.jpg)



### 1.2 段寄存器

8086CPU有4个段寄存器：CS、DS、SS、ES。

8086CPU大部分寄存器可以通过mov指令修改，但段寄存器不能通过这种方式修改。

8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移
地址，送入地址加法器合成物理地址。段地址在8086CPU的段寄存器中存放。

当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。

#### 1.1.1 CS 和 IP

CS和IP指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器，在8086PC机中，任意时刻，8086CPU将从内存 `[CS]x16+[IP]` 单元开始，读取一条指令并执行。

简要描述CPU的工作过程：

(I)从CS:P指向的内存单元读取指令，读取的指令进入指令缓冲器；

(2)P-P+所读取指令的长度，从而指向下一条指令；

(3)执行指令。转到步骤(1)，重复这个过程。

小知识：在8086CPU加电启动或复位后(即CPU刚开始工作时)CS和IP被设置为
CS=FFFFH,IP=0000H,即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令
执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

1. ​



#### 1.1.2 DS寄存器

通常用来存放要访问数据的段地址。

用法：

```assembly
mov bx, 1000H

mov ds, bx

mov al, [0]      // 1
mov al, ds:[0]   // 2
```

1、2 两条指令均表示，取段地址为ds，0为偏移地址的内存处的数据保存到al中。

#### 1.1.3 SS和SP

段寄存器SS存放栈顶的段地址，寄存器SP存放栈顶的偏移地址。任意时刻，SS:SP指向栈顶元素。



#### 1.1.4 SI 和 DI

si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器
来使用。

### 1.3 标志寄存器

ag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个
含义。而fag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定
的信息。
8086CPU的flag寄存器的结构如图所示。

![Dingtalk_20220524161713](E:\学习资料\OperationSystem\OperationSystem-S6.828\相关知识笔记\Dingtalk_20220524161713.jpg)

#### 1.3.1  ZF标志

fg的第6位是ZF,零标志位。它记录相关指令执行后，其结果是否为0。如果结果
为0，那么zf=1;如果结果不为0，那么zf=0.
比如，指令：
mov ax,1
sub ax,1
执行后，结果为0，则zf=1.
mov ax,2
sub ax,1
执行后，结果不为0，则zf=0。

#### 1.3.2 PF标志

fag的第2位是P℉，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，pf=1,如果为奇数，那么pf=0.
比如，指令：

mov al,1
add al,10
执行后，结果为00001011B,其中有3（奇数）个1，则pf=0；

mov al,1
or al,2
执行后，结果为00000011B,其中有2（偶数）个1，则pf=1;

sub al,al
执行后，结果为00000000B,其中有0（偶数）个1，则pf1。



#### 1.3.3 SF标志

fag的第7位是SF,符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，sf=1;如果非负，sf=0。

#### 1.3.4 CF标志

flag的第0位是CF,进位标志位。一般情况下，在进行无符号数运算的时候，它记
录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。
对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是
它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位。

mov al,98H
add al,al			;执行后：(a1)=30H,CF=1,CF记录了从最高有效位向更高位的进位值
add al,al			;执行后：(al)=60H,CF=0,CF记录了从最高有效位向更高位的进位值
mov al,97H
sub al,98H		;执行后：(a1)=FH,CF=1,CF记录了向更高位的借位值
sub al,al			;执行后：(al)=0,CF=0,CF记录了向更高位的借位值



#### 1.3.4 OF标志

flag的第11位是OF,溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1;如果没有，OF=0。

#### 1.3.5 DF标志和串传送指令



flag的第l0位是DF,方向标志位。在串处理指令中，控制每次操作后si、di的增减。

df=0：每次操作后si、di递增；
df=l：每次操作后si、di递减。



1.3.6 标志寄存器在Debug中的表示

![Dingtalk_20220524175110](E:\学习资料\OperationSystem\OperationSystem-S6.828\相关知识笔记\Dingtalk_20220524175110.jpg)

#### 1.3.6 TF标志与单步中断

CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生
单步中断，引发中断过程。



1.3.7 IF标志

当CPU的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU的内部。还有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。

外中断源一共有以下两类：

**可屏蔽中断：**

可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的F位的设置。当CPU检测到可屏蔽中断信息时，如果F=1,则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0,则不响应可屏蔽中断。

内中断所引发的中断过程：
(1)取中断类型码n:
(2)标志寄存器入栈，F=0,TF=0:
(3)CS、P入栈：
(4)(IP)=(n\*4),(CS)=(n\*4+2)
由此转去执行中断处理程序。

将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。

当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。8086CPU
提供的设置F的指令如下：
sti,设置IF=1；
cli,设置IF=0。

**不可屏蔽中断：**

不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在
执行完当前指令后，立即响应，引发中断过程。对于8086CPU,不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：
(1) 标志寄存器入栈，IF=0,TF=0；
(2) CS、IP入栈；
(3) (IP)=(8),(CS)=(0AHD)







## 2 指令

### 2.1 汇编指令

#### 2.1.1 mov、add、sub指令

mov指令的用法：

mov  寄存器，数据          比如：mov ax,8

mov  寄存器，寄存器      比如：mov ax,bx

mov  寄存器，内存单元   比如：mov ax,[0]

mov内存单元，寄存器     比如：mov[0],ax

mov  段寄存器，寄存器   比如：mov ds,ax

不支持： add ds, [0]

#### 2.1.2 栈机制

**push、pop指令实现入栈和出栈指令。**

push ax 的执行分两步：

(1)SP=SP-2,SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；

(2)将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

pop ax 的执行与push相反：

(I)将SS:SP指向的内存单元处的数据送入ax中；

(2)SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的
栈顶。

push和pop指令的格式可以是如下形式：

（1）

push 寄存器      将一个寄存器中的数据入栈
pop   寄存器      出栈，用一个寄存器接收出栈的数据

（2）

push  段寄存器    将一个段寄存器中的数据入栈 
pop    段寄存器    出栈，用一个段寄存器接收出栈的数据

（3）

push  内存单元    将一个内存字单元处的字入栈(注意：栈操作都是以字为单位)
pop    内存单元    出栈，用一个内存字单元接收出栈的数据

**pushf和popf**

pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。





#### 2.1.3 Loop指令

格式：  loop 标号

操作步骤

（1）cx = cx - 1

（2）判断cx中的值，不为0则转至标号处执行程序，否则向下执行。

代码示例：

```assembly
assume cs:code
code segment
	mov ax,2
	mov cx,11
s:	add ax,ax
	loop s
	mov ax,4c00h
	int 21h
code ends
end
```



#### 2.1.4 and 和 or 指令



and: 按位与

or:   按位或



#### 2.1.5 div 指令

div 是除法指令，该指令的使用遵循以下规则：

(1)除数：有8位和16位两种，在一个reg或内存单元中。

(2)被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，
默认在AX中存放：如果除数为16位，被除数则为32位，在DX和AX中存放，DX存
放高16位，AX存放低16位。

(3)结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数：
如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。

#### 2.1.6 dup

dup是一个操作符，在汇编语言中同d、dw、dd等一样，也是由编译器识别处理的
符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。

指令格式：

db重复的次数dup（重复的字节型数据）
dw重复的次数dup（重复的字型数据）
dd重复的次数dup（重复的双字型数据）

示例：

```assembly
db 3 dup (0)
;定义了3个字节，它们的值都是0，相当于 db 0,0,0
db 3 dup (0,1,2)
;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0,1,2,0,1,2,0,1,2
db 3 dup ('abc','ABC')
;定义了18个字节，它们是'abcABCabcABCabcABC',相当于db 'abcABCabcABCabcABC'
```

#### 2.1.7 转移指令

可以修改P,或同时修改CS和IP的指令统称为转移指令。

8086CPU的转移行为有以下几类：

- 只修改IP时，称为段内转移，比如：jmp ax.
- 同时修改CS和P时，称为段间转移，比如：jmp1000:0.

由于转移指令对P的修改范围不同，段内转移又分为：短转移和近转移。

- 短转移P的修改范围为-128~127.
- 近转移IP的修改范围为-32768~32767.

8086CPU的转移指令分为以下几类。

- 无条件转移指令(如：jmp)
- 条件转移指令
- 循环指令(如：loop)
- 过程
- 中断

**jmp 指令**

jmp为无条件转移指令，可以只修改IP，也可同时修改CS和IP。

(1)转移的目的地址
(2)转移的距离(段间转移、段内短转移、段内近转移)



1. jmp short 标号          ;转到标号处执行指令  	(IP)=(IP)+8位位移。

   jmp near ptr  标号    ; 段内近转移			(IP)=(IP)+16位位移。

这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127（-32768~32767），也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。jmp指
令中的“short'”符号，说明指令进行的是短转移。jmp指令中的“标号”是代码段中的标
号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。



示例：

```assembly
assume cs:codesg
codesg segment
start:	 mov ax,0
		jmp short s
		add ax,1
s:		inc ax
codesg ends
end start
```

![Dingtalk_20220524115045](E:\学习资料\OperationSystem\OperationSystem-S6.828\相关知识笔记\Dingtalk_20220524115045.jpg)

转移位移的计算方法



2. ​

  ​“jmp far ptr标号”实现的是段间转移，又称为远转移。功能如下：

  ​(CS)=标号所在段的段地址：P)=标号在段中的偏移地址。
  ​far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP。

3. ​

8086CPU大部分寄存器可以通过mov指令修改，但CS、IP不能通过这种方式修改。

修改CS、IP的指令 ：jmp 指令

使用方式：

1. jmp 段地址：偏移地址     作用：用指令中段地址、偏移地址分别修改CS、IP寄存器的值。
2. jmp 寄存器                         作用：用寄存器的值修改IP







4. 转移地址在内存中的jmp指令

转移地址在内存中的jmp指令有两种格式：
(I)jmp word ptr内存单元地址（段内转移）
功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。
内存单元地址可用寻址方式的任一格式给出。

(2)jmp dword ptr内存单元地址（段间转移）
功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低
地址处是转移的目的偏移地址。
(CS)=(内存单元地址+2)
（IP)=（内存单元地址）
内存单元地址可用寻址方式的任一格式给出。



#### 2.1.8 jcxz指令



jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中
包含转移的位移，而不是目的地址。对P的修改范围都为：-128~127。

指令格式：jcxz标号(如果（cx)=0,转移到标号处执行。
操作：当(cx)0时，(P)=(P)+8位位移，8位位移=标号处的地址-jCxz 指令后的第一个字节的地址；
当(cx)≠0时，什么也不做（程序向下执行）。

#### 2.1.9 条件转移指令

除了jCxz之外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改P。检测的标志位就是被cmp指令影响的那些，表示比较结果的标志位。这些条件转移指令通常都和cmp相配合使用。

因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据
cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的
条件转移指令(它们检测zf、cf的值)和根据有符号数的比较结果进行转移的条件转移指令
(它们检测sf、of和zf的值)。

无符号数的比较结果进行转移的条件转移指令。
指令					含义			检测的相关标志位
je					等于则转移			zf=1
jne					不等于则转移			zf=0
jb					低于则转移			cf=1
jnb					不低于则转移			cf=0
ja					高于则转移			cf=0且zf=0
jna					不高于则转移			cf=1或zf=1

以上指令第一个字母都是j, 表示jump；后面的字母表示意义如下：
e:		表示equal
ne:		表示not equal
b:		表示below
nb:		表示not below
a:		表示above
na:		表示not above



#### 2.1.10 call 和 ret 指令

**ret和retf**

ret指令用栈中的数据，修改IP的内容，从而实现近转移：
retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。
CPU执行ret指令时，进行下面两步操作：
(1) (IP)=(ss)*16+(sp)
(2) (sp)=(sp)+2

CPU执行retf指令时，进行下面4步操作：
(1) (IP)=(ss)*16+(sp)
(2) (sp)(sp)+2
(3) (CS)=(ss)*16+sp)
(4) (sp)=(sp)+2

**call指令**

CPU执行call 指令时，进行两步操作：
(1)将当前的P或CS和P压入栈中：
(2)转移。

call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相
同。
要应用格式。

1.  call标号 (将当前的P压栈后，转到标号处执行指令)

   CPU执行此种格式的call指令时，进行如下的操作：
   (1) (sp)=(sp)2
   (ss)*16+(sp)-(IP)
   (2) (IP)=(IP)+16位位移。



2. ​

call far ptr   标号”实现的是段间转移。
CPU执行此种格式的call指令时，进行如下的操作。
(1)
(sp)=(sp)2
(ss)*16+(sp)=(CS)
(sp)=(sp)2
(sS)*16+(sp)=(IP)
(2)
(CS)=标号所在段的段地址
P)=标号在段中的偏移地址
从上面的描述中可以看出，如果我们用汇编语法来解释此种格式的cl指令，则：
CPU执行“call far ptr标号”时，相当于进行：
push CS
push Ip
jmp far ptr标号

3. ​

指令格式：call 16位reg
功能：
(sp)=(sp)2
(sS)*16+(sp)=(P)
IP)=(16位reg)
用汇编语法来解释此种格式的call指令，CPU执行“call 16位reg”时，相当于
进行：
push Ip
jmp16位reg

4. 转移地址在内存中的call 指令

(I)call word ptr内存单元地址
用汇编语法来解释此种格式的call指令，则：
CPU执行“call word ptr内存单元地址”时，相当于进行：
push Ip
jmp word ptr内存单元地址

(2)call dword ptr内存单元地址
用汇编语法来解释此种格式的call指令，则：
CPU执行“call dword ptr内存单元地址”时，相当于进行：
push CS
push IP
jmp dword ptr 内存单元地址



#### 2.1.11 mul 指令

mul是乘法指令，使用mul做乘法的时候应遵循以下规则：
(1)两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，
一个默认放在AL中，另一个放在8位rg或内存字节单元中；如果是16位，一个默认在
AX中，另一个放在16位reg或内存字单元中。
(2)结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默
认在DX中存放，低位在AX中放。



#### 2.1.12 adc 与sbb指令

**adc是带进位加法指令**，它利用了CF位上记录的进位值。
指令格式：adc  操作对象1，操作对象2
功能：操作对象1=操作对象1+操作对象2+CF
比如指令adc ax,bx实现的功能是：(ax)=(ax)+(bx)+CF

示例：

编程，计算1EF000H+201000H,结果放在ax(高16位)和bx(低16位)中。
因为两个数据的位数都大于16，用add指令无法进行计算。我们将计算分两步进
行，先将低16位相加，然后将高16位和进位值相加。程序如下。

```assembly
mov ax,001EH
mov bx,0F000H
add bx,1000H
adc ax,0020H
```



**sbb是带借位减法指令**，它利用了CF位上记录的借位值。
指令格式：sbb操作对象1，操作对象2
功能：操作对象1=操作对象1-操作对象2-CF
比如指令sbb ax,bx实现的功能是：(ax)=(ax)-(bx)-CF
sbb指令执行后，将对C℉进行设置。利用sbb指令可以对任意大的数据进行减法运算。

比如，计算003E1000H-00202000H,结果放在ax,bx中，程序如下：

```assembly
mov bx,1000H
mov ax,003EH
sub bx,2000H
sbb ax,0020H
```



#### 2.1.13 cmp 指令

cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。

cmp指令格式：cmp操作对象l,操作对象2

功能：计算操作对象1-操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。

比如，指令cmp ax, ax,做(ax) - (ax)的运算，结果为0，但并不在ax中保存，仅影响

flag的相关各位。指令执行后：zf=1,pf=1,sf=0,cf=0,of=0。

#### 2.1.14 中断与 iret  指令

中断产生时，CPU会获得一个中断类型码(0~256)，在中断向量表中找到中断处理程序
的入口。中断向量表位于内存的 0 ~ 3FF 处，每个中断类型码按数值大小获取该处的4字节内存，高地址存放段地址，低地址存放偏移地址。找到这个入口地址的最终目的是用它设置CS和P,使CPU执行中断处理程序。用中断类型码找到中断向量，并用它设置CS和P,这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。

中断过程的简洁描述：
(1) 取得中断类型码N;
(2) pushf
(3) TF=0,F=0
(4) push CS
(5) push IP
(6) (IP)=N\*4), （CS)=N\*4+2

在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。

中断处理程序的编写和子程序类似：

(1) 保存用到的寄存器：
(2) 处理中断：
(3) 恢复用到的寄存器：
(4) 用iret指令返回。
iret指令的功能用汇编语法描述为：
pop IP
pop CS
popf

#### 2.1.15 int指令

int 指令引发中断，其格式为  `int n` ， n为中断类型码。

CPU执行intn指令，相当于引发一个n号中断的中断过程，执行过程如下：
(1) 取中断类型码n:
(2) 标志寄存器入栈，IF=0,TF=0:
(3) CS、P入栈；
(4) (IP)=(n\*4),(CS)=(n\*4+2)
从此处转去执行号中断的中断处理程序。



#### 2.1.16 端口的读写

对端口的读写不能用mov、push、pop等内存读写指令。端口的读写指令只有两条：
in和out,分别用于从端口读取数据和往端口写入数据。

在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al,访问l6位端口时用ax。
对0255以内的端口进行读写时：
in al,20h		;从20h端口读入一个字节

out 20h,al	;往20h端口写入一个字节



对25665535的端口进行读写时，端口号放在dx中：
mov dx,3f8h		;将端口号3f8h送入dx
in al,dx			;从3f8h端口读入一个字节
out dx,al			;向3f8h端口写入一个字节





#### 2.1.17 shl和shr指令

shl和shr分别是逻辑左移和右移指令。功能为：

(1)将一个寄存器或内存单元中的数据向左移位；
(2)将最后移出的一位写入CF中；
(3)最低位用0补充。

示例1：

mova1,01001000b
shl al,1 	;将al中的数据左移一位
执行后(al)=10010000b,CF=0。



示例2：

如果移动位数大于1时，必须将移动位数放在cl中。
mova1,01010001b
mov cl, 3
shl al, cl



### 2.2 伪指令

#### 2.2.1 db、dw、dd

前面我们用db和dw定义字节型数据和字型数据。dd是用来定义dword(double
word,双字）型数据的。比如：

```assembly
data segment
db 1
dw 1
dd 1
data ends
```

在data段中定义了3个数据：
第一个数据为01H,在data:0处，占1个字节：
第二个数据为0001H,在data:1处，占1个字（即2个字节）
第三个数据为00000001H,在data:3处，占2个字（即4个字节）。

#### 2.2.2 操作符 offset

```assembly
assume cs:codesg
codesg segment
start:	  mov ax,offset start	 ; 相当于mov ax,0
s:        mov ax,offset s		 ; 相当于mov ax,3
codesg ends
end start
```









## 3 地址及内存访问

### 3.1 CPU寻址基本原理

8086CPU有20位地址总线，可以传送20位地址，寻址空间位1MB。而CPU的内部结构只能送出16位的地址，表现出的寻址空间为64KB。

![Dingtalk_20220523135507](E:\学习资料\OperationSystem\OperationSystem-S6.828\相关知识笔记\Dingtalk_20220523135507.jpg)

8086CPU的地址转换及传输步骤：
(1) CU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；
(2) 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；
(3) 地址加法器将两个16位地址合成为一个20位的物理地址，合成规则为 段地址 << 4 + 偏移地址（段地址左移4位加偏移地址）；
(4) 地址加法器通过内部总线将20位物理地址送入输入输出控制电路；
(5) 输入输出控制电路将20位物理地址送上地址总线；
(6) 20位物理地址被地址总线传送到存储器。





### 3.2 内存访问方式

**通过 `[]` 符号访问内存**

[...] 表示访问内存单元，如 `mov ax, [bx]`   表示将bx中存放的数据作为偏移地址（段地址为 ds）。

**段前缀**

可以通过显示指定段地址的方式访问内存，如

```assembly
mov ax, ds:[bx]
mov ax, cs:[bx]
mov ax, ss:[bx]
mov ax, es:[bx]
```

**[bx + idata]寻址方式**

示例： `mov ax, [bx+200]`   可同样写为  `mov ax, 200[bx]`  

表示将偏移地址为 bx 的值加200的内存单元的两个字节存放到ax中。

**寻址寄存器: bx, si, di, bp**

(1) 在8086CPU中，只有这bx、si、di和bp 4个寄存器可以用用 [] 来进行内存单元的寻址。

(2) 在使用 [] 时，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di。

(3)只要在 [] 中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在
ss中。比如下面的指令。



**指令处理数据的长度**

（1）通过寄存器名指明要处理的数据的尺寸。
例如，下面的指令中，寄存器指明了指令进行的是字操作。

```assembly
mov ax,1
mov bx,ds:[0]
mov ds,ax
mov ds:[0],ax
inc ax
add ax,1000
```


下面的指令中，寄存器指明了指令进行的是字节操作。

```assembly
mov al,1
mov al,bl
mov al,ds:[0]
mov ds:[0],al
inc al
add al,100
```

(2)在没有寄存器名存在的情况下，用操作符Xpr指明内存单元的长度，X在汇编
指令中可以为word或byte。

例如，下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元。

```assembly
mov word ptr ds:[0],1
inc word ptr [bx]
inc word ptr ds:[0]
add word ptr [bx],2
```

下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元。

```assembly
mov byte ptr ds:[0],1
inc byte ptr [bx]
inc byte ptr ds:[0]
add byte ptr [bx],2
```

**寻址方式的结构化表示**

对于如下C结构的结构体：

```c
struct company{
char cn[3];
char hn[9];
int pm;
int sr;
char cp[3];
}；
```

可用如下所示的汇编语言进行处理：

```assembly
mov ax, seg
mov ds, ax
mov bx, 60h
mov word ptr [bx].0ch, 38             ; pm = 38
add word ptr [bx].0eh, 70			 ; sr += 70
mov si, 0
mov byte ptr [bx].10h[si], 'V'        ; 字节操作，cp[0] = 'V'
inc si
mov byte ptr [bx].10h[si], 'A'		 ; 字节操作，cp[1] = 'A'
inc si
mov byte ptr [bx].10h[si], 'x'		 ; 字节操作，cp[1] = 'x'
```





## 4 汇编语法

### 4.1 AT&T

寄存器命令：			%eax

源/目标顺序：		mov 源， 目标

常量/立即数格式：	movl $_booga,  %eax 		;在变量前加  ‘\$’ 符号

​					movl $0xd00d, %ebx

寻址方式：			immed32(basepointer,indexpointer,indexscale)

等价于  immed32 + basepointer + indexpointer * indexscale

示例：

```assembly
(%eax)
_variable(%eax)	; variable + eax
_array(,%eax,4)	; array + 4 * eax
1(%eax)		   ; eax + 1
_struct_pointer+8 
_array(%ebx,%eax,8)	; array + ebx + 8 * eax
```

注意:下划线(“_”)是获得静态(全局)C变量。这只适用于全局变量。否则，您可以使用扩展asm将变量预加载到寄存器中。





### 4.2 Intel

寄存器命令：			eax

源/目标顺序：		mov 目标， 源

常量/立即数格式：	mov eax, _booga

​					mov ebx, d00dh

寻址方式：			[basepointer + indexpointer*indexscale + immed32]

示例：

```assembly
[_booga]
[eax]
[eax + _variable]
[eax*4 + array]
[eax + 1]
[ebx + eax*8 + _array]
```





### 4.3 内嵌汇编

**基础语法**		asm ("statements");

asm 与 \_\_asm\_\_ 作用相同

```assembly
asm ("pushl %eax\n\t"
     "movl $0, %eax\n\t"
     "popl %eax");
```

https://zhuanlan.zhihu.com/p/395130640